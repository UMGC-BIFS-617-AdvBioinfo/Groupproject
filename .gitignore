#Start group project here. 

#Karina
import os
import re
def main():
    
    startup_message()#Display the start-up message
    my_seq=input("Enter your file name\n")#ask name of file
    orf_length=eval(input("enter the minimum orf's length ")) 
    #ask for length orf
    info={}#creates dictionary
    with open(my_seq)as file:#open file
        for line in file:
            line=line.upper().rstrip('\n').replace("-","")#convert to upper,get rid of newlines and gaps
            if line.startswith('>'):
                header=line[1:]
                info[header]=''#Here we have the dictionary info with the key header that have all the lines that start with >, there is no value yet
                continue
            else:
                info[header]=info[header]+line#here we add the value(the lines that do not have >
    #print(info)
#Using the values from the dictionary we call the functions(read_file1, read_file2, read_file3) in order to find the reading frames. The argument(x)is
    #each value of the dictionary(each dna sequence)
    
    count=0
    frames=[]
    ORFlist=[]
    for x in info.values():
        count+=1
        print("sequence",count)#it counts the sequences in the file in order to get a clearer output
        reading1=read_file1(x)
        frames.append(reading1)
        
        reading2=read_file2(x)
        frames.append(reading2)
        reading3=read_file3(x)
        frames.append(reading3)
        comp_strand=makereverse(x)
        #print("Complementary strand ",comp_strand)    
        re_com_strand=reverse(comp_strand)
        #print("reverse str",re_com_strand)
        reading4=read_file4(re_com_strand)
        frames.append(reading4)
        
        reading5=read_file5(re_com_strand)
        frames.append(reading5)
        
        reading6=read_file6(re_com_strand)
        frames.append(reading6)
        print("frames",frames)
        
    
#This part here was the part that I started a couple of hours ago trying to find orfs when I realized that the orf fiding function that we have is not working. 
#It is an example that I got from internet, so we cannot use it and it is not working but it can give us an idea.
    for i in range(len(frames)): #looping all the frames
        start=0
        while start <len(frames[i]): #looping each frame for start and stop codons 
            if frames[i][start]=="ATG" or frames[i][start]=="AUG":
                for stop in range(start+1,len(frames[i])):
                         if frames[i][stop]=="TAA" or  frames[i][stop]=="TAG" or  frames[i][stop]=="TGA" :
                                ORFlist.append(frames[i][start:stop]) # retrieve the orf 
            start+=1
    print("ORFlist ",str(ORFlist))
    

#we define the funtions called above    
def startup_message():
    print("""This program will find the orfs in your sequence.Enter the name
    of your sequence and press enter to continue\n\n""")

def read_file1(dna):
    for x in dna:
        reading1=dna[0:]#reading1 starts in the position 0 for each dna sequence(x)=reading frame1
        return reading1
def read_file2(dna): 
    for x in dna:
        reading2=dna[1:]#same position1=reading frame2
        return reading2
def read_file3(dna):
    for x in dna:
        reading3=dna[2:]#same position2=reading frame 3
        return reading3

    

# this part was Sandra

# convert to reverse compliment 
# than use this in a loop to process multiple seqs in a file.
def makereverse(Seq):
    #first change from upper to lowercase
    seqA2t=Seq.replace("A","t")
    seqT2a=seqA2t.replace("T","a")
    seqC2g=seqT2a.replace("C", "g")
    seqG2c=seqC2g.replace("G","c")
    seqdnacomp=seqG2c.upper()
    return seqdnacomp
def reverse(x):
    re_seq=x[::-1]
    return re_seq
def read_file4(dna):
    for x in dna:
        reading4=dna[0:]#reading1 starts in the position 0 for each dna sequence(x)=reading frame1
        return reading4
def read_file5(dna): 
    for x in dna:
        reading5=dna[1:]#same position1=reading frame2
        return reading5
def read_file6(dna):
    for x in dna:
        reading6=dna[2:]#same position2=reading frame 3
        return reading6    






main()
###Here ends the part that Karina was runing It has parts from Sandra and from me because I put both parts together in order to run the code 
#and see the results.The parts were from before the update that Sandra made yesterday night
#the output until here is:
#seq1
#frames[seq in frame1, seq in frame2, seq in frame3, seq in frame4, until frame 6]
#seq2
#frames [seq in frame1,until frame6] and the same repeats until the last sequence in the file
#Then I tried to loop the list frames into a function that finds orfs but it didn't work.When I put the orf funcion from Sandra the output was:
#seq 1
#orf in frame1:and the orf sequence
#orf in frame2: and the orf sequence, the same for each frame in each sequence but it only found one orfs where there were more and trying different 
#sequences found orfs where ther weren't.


#Sandra
#part 3 
#work in progess
#import form my part of code remove in final only need once
import re
# convert to reverse compliment 
# than use this in a loop to process multiple seqs in a file.
# convert to reverse compliment 
# than use this in a loop to process multiple seqs in a file.
#updated makereversefunction to actually reverse and not just complement.
def makereverse(seq): #Author Sandra Shannon
    #first change from upper to lowercase
    seqA2t=seq.replace("A","t")
    seqT2a=seqA2t.replace("T","a")
    seqC2g=seqT2a.replace("C", "g")
    seqG2c=seqC2g.replace("G","c")
    seqdnacomp=seqG2c.upper()
    seqdnareversed=seqdnacomp[::-1]
    return seqdnareversed
    
#new code 16Mar2021
#test sequences 
TestSeq= """CCTCAGCGAGGACAGCAAGGGACTAGCCAGGAGGGAGAACAGAAACTCCAGAACATCTTGGAAATAGCTCCCAGAAAAGCAAGCAGCCAACCAGGCAGGTTCTGTCCCTTTCACTCACTGGCCCAAGGCGCCACATCTCCCTCCAGAAAAGACACCATGAGCACAGAAAGCATGATCCGCGACGTGGAACTGGCAGAAGAGGCACTCCCCCAAAAGATGGGGGGCTTCCAGAACTCCAGGCGGTGCCTATGTCTCAGCCTCTTCTCATTCCTGCTTGTGGCAGGGGCCACCACGCTCTTCTGTCTACTGAACTTCGGGGTGATCGGTCCCCAAAGGGATGAGAAGTTCCCAAATGGCCTCCCTCTCATCAGTTCTATGGCCCAGACCCTCACACTCAGATCATCTTCTCAAAATTCGAGTGACAAGCCTGTAGCCCACGTCGTAGCAAACCACCAAGTGGAGGAGCAGCTGGAGTGGCTGAGCCAGCGCGCCAACGCCCTCCTGGCCAACGGCATGGATCTCAAAGACAACCAACTAGTGGTGCCAGCCGATGGGTTGTACCTTGTCTACTCCCAGGTTCTCTTCAAGGGACAAGGCTGCCCCGACTACGTGCTCCTCACCCACACCGTCAGCCGATTTGCTATCTCATACCAGGAGAAAGTCAACCTCCTCTCTGCCGTCAAGAGCCCCTGCCCCAAGGACACCCCTGAGGGGGCTGAGCTCAAACCCTGGTATGAGCCCATATACCTGGGAGGAGTCTTCCAGCTGGAGAAGGGGGACCAACTCAGCGCTGAGGTCAATCTGCCCAAGTACTTAGACTTTGCGGAGTCCGGGCAGGTCTACTTTGGAGTCATTGCTCTGTGAAGGGAATGGGTGTTCATCCATTCTCTACCCAGCCCCCACTCTGACCCCTTTACTCTGACCCCTTTATTGTCTACTCCTCAGAGCCCCCAGTCTGTATCCTTCTAACTTAGAAAGGGGATTATGGCTCAGGGTCCAACTCTGTGCTCAGAGCTTTCAACAACTACTCAGAAACACAAGATGCTGGGACAGTGACCTGGACTGTGGGCCTCTCATGCACCACCATCAAGGACTCAAATGGGCTTTCCGAATTCACTGGAGCCTCGAATGTCCATTCCTGAGTTCTGCAAAGGGAGAGTGGTCAGGTTGCCTCTGTCTCAGAATGAGGCTGGATAAGATCTCAGGCCTTCCTACCTTCAGACCTTTCCAGATTCTTCCCTGAGGTGCAATGCACAGCCTTCCTCACAGAGCCAGCCCCCCTCTATTTATATTTGCACTTATTATTTATTATTTATTTATTATTTATTTATTTGCTTATGAATGTATTTATTTGGAAGGCCGGGGTGTCCTGGAGGACCCAGTGTGGGAAGCTGTCTTCAGACAGACATGTTTTCTGTGAAAACGGAGCTGAGCTGTCCCCACCTGGCCTCTCTACCTTGTTGCCTCCTCTTTTGCTTATGTTTAAAACAAAATATTTATCTAACCCAATTGTCTTAATAACGCTGATTTGGTGACCAGGCTGTCGCTACATCACTGAACCTCTGCTCCCCACGGGAGCCGTGACTGTAATCGCCCTACGGGTCATTGAGAGAAATAA"""
#function for open reading frames.#Author Sandra Shannon
orf_length=eval(input("enter the minimum orf's length "))#ask for length orf
def findORF(seqtosearch, orf_length):
    min=orf_length
    pattern="A[TU]G[AUTGC]{" +str(min)+ """,}(TAA|TAG|TGA)"""
    for key, value in seqtosearch.items():
        ORF=re.finditer(pattern, value)
        for match in ORF:
            run_start=match.start()
            seq=match.group()
            run_len=len(seq)
            print("|FRAME="+key+" POS="+str(run_start)+" LEN="+str(run_len)+"\n"+seq)


        

#Sandra- todo find 4-6 ORFS, strat postion, len-done startpostion, len and seq
#16Mar2020 sandra new todo match input code to here, creat a new dictorany to store the print("|FRAME... data.)
    
#new code 23Mar2021 SBS
#function for getting the Frames #Author Sandra Shannon
def findingframesfoward(seq): 
    nextstartbase=0
    frameconter=1
    frames={}
    for start in range(0,3):
        seqofframe=seq[nextstartbase:len(seq)]
        key=str(frameconter)
        value=seqofframe
        frames[key]=value
        #print(frames)
        nextstartbase+=1
        frameconter+=1
    return frames

def findingframesreverse(reverseseq): #Author Sandra Shannon
    nextstartbase=0
    frameconter=4
    frames={}
    for start in range(0,3):
        seqofframe=reverseseq[nextstartbase:len(reverseseq)]
        key=str(frameconter)
        value=seqofframe
        frames[key]=value
        #print(frames)
        nextstartbase+=1
        frameconter+=1
    return frames


#Testing stuff
reverseseq=makereverse(TestSeq)       
#print(findingframesfoward(TestSeq))
#print(findingframesreverse(reverseseq))
frowardframes=findingframesfoward(TestSeq)
reverseframes=findingframesreverse(reverseseq)
ORFs=findORF(frowardframes, orf_length)
ORFs=findORF(reverseframes,orf_length)
#to do make the functions makereverse(seq) findingframesfoward(seq) findingframesreverse(reverseseq) work with the input dictonary. This can be done similar to the  findORF function
