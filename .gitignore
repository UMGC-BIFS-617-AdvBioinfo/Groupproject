#Start group project here. 

#Karina
import os
import re


def main():
    
    startup_message()#Display the start-up message
    my_seq=input("Enter your file name\n")#ask name of file
    orf_length=eval(input("enter the minimum orf's length "))#ask for length orf
    info={}#creates dictionary
    with open(my_seq)as file:#open file
        for line in file:
            line=line.upper().rstrip('\n').replace("-","")#convert to upper,get rid of newlines and gaps
            if line.startswith('>'):
                header=line[1:]
                info[header]=''#Here we have the dictionary info with the key header that have all the lines that start with >, there is no value yet
                continue
            else:
                info[header]=info[header]+line#here we add the value(the lines that do not have >
   
#Using the values from the dictionary we call the functions(read_file1, read_file2, read_file3) in order to find the reading frames. The argument(x)is
    #each value of the dictionary(each dna sequence)
    
    count=0
    for x in info.values():
        count+=1
        print("sequence",count)#it counts the sequences in the file in order to get a clearer output
        reading1=read_file1(x)
        reading2=read_file2(x)
        reading3=read_file3(x)
        
        
        orf_1=find_orfs(reading1)
        for x in orf_1:
            leng_orf=len(x)#for the length of orfs in reading frame 1 for each sequence in file
            if leng_orf>=orf_length:
                print("orf1 ",x,"length ",leng_orf)#only prints the orfs and length that are equal or greater to the user input length in reading frame1
            else:
                orf_length==leng_orf
                print("the minimum is 50",x,leng_orf)
                #orf_length=int(input("enter the minimum orf's length "))
                
        orf_2=find_orfs(reading2)
        for x in orf_2:
            leng_orf=len(x)#for the length of orfs in reading frame 2 for each sequence in file
            if leng_orf>=orf_length:
                print("orf2 ",x,"length ",leng_orf)#only prints the orfs and length that are equal or greater to the user input lengthorf_3=find_orfs(reading3)
        orf_3=find_orfs(reading3)
        for x in orf_3:
            leng_orf=len(x)#for the length of orfs in reading frame 1 for each sequence in file
            if leng_orf>=orf_length:
                print("orf3 ",x,"length ",leng_orf)#only prints the orfs and length that are equal or greater to the user input length
            
        
        
#we define the funtions called above    
def startup_message():
    print("""This program will find the orfs in your sequence.Enter the name
    of your sequence and press enter to continue\n\n""")

def read_file1(dna):
    for x in dna:
        reading1=dna[0:]#reading1 starts in the position 0 for each dna sequence(x)=reading frame1
        return reading1
def read_file2(dna): 
    for x in dna:
        reading2=dna[1:]#same position1=reading frame2
        return reading2
def read_file3(dna):
    for x in dna:
        reading3=dna[2:]#same position2=reading frame 3
        return reading3

    
def find_orfs(dna):
            pattern=re.findall(r"A[TU]G[AUTGC]{50,}T[AG][AG]",dna)#use regex to find orfs we have to change the regex in order to accomodate the user length
            return pattern


main()



#Sandra
#part 3 
#work in progess
# convert to reverse compliment 
# than use this in a loop to process multiple seqs in a file.
def makereverse(Seq):
    #first change from upper to lowercase
    seqA2t=Seq.replace("A","t")
    seqT2a=seqA2t.replace("T","a")
    seqC2g=seqT2a.replace("C", "g")
    seqG2c=seqC2g.replace("G","c")
    seqdnacomp=seqG2c.upper()
    return seqdnacomp
#Sandra- todo find 4-6 ORFS, strat postion, len
