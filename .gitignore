import os
import re


#Karina's code
#startup_message()#Display the start-up message #I think this is supposed to be a function of something 
    #it does not do anything


#Sandra put Karina's code in a function to run it below in the main function. 
#Sandra also made a get orf_length function to use later 
#So sandra just broke Karina's code into two piece but did not change the code. 
def get_orflength():
    orf_length=eval(input("enter the minimum orf's length "))#ask for length orf
    return orf_length
def getfile_info():
    my_seq=input("Enter your file name\n")#ask name of file
    info={}#creates dictionary
    with open(my_seq)as file:#open file
        for line in file:
            line=line.upper().rstrip('\n').replace("-","")#convert to upper,get rid of newlines and gaps
            if line.startswith('>'):
                header=line[1:]
                info[header]=''#Here we have the dictionary info with the key header that have all the lines that start with >, there is no value yet
                continue
            else:
                info[header]=info[header]+line #here we add the value(the lines that do not have >
    print("This is the info dictionary:" ) #comment this out in final code
    print(info) #comment this out in final code. 
    return info




#Sandra's code
#This function will be used to complement ande reverse the values in the info dictionary created
#by Karina's code 
#It makes a new dictionary 
#The key= the same key from info dictionary "Accession#/name"
#The value= the seq complemted and reversed.
def makereverse(seq): #Author Sandra Shannon
    #first change from upper to lowercase
    reverseseqdic={}
    for key, value in seq.items():
        seqA2t=value.replace("A","t")
        seqT2a=seqA2t.replace("T","a")
        seqC2g=seqT2a.replace("C", "g")
        seqG2c=seqC2g.replace("G","c")
        seqdnacomp=seqG2c.upper()
        seqdnareversed=seqdnacomp[::-1]
        samekey=key
        rsdvalue=seqdnareversed
        reverseseqdic[samekey]=seqdnareversed
    #print(reverseseqdic)
    return reverseseqdic
    
#This code splits the DNA seq into codons if can be ran on the sequences 
# This function is used inside the finding frames functions. 
#It only works on one sequence at a time 
#The output is a string. 
def splitintocodon(DNAseq): #Author Sandra Shannon
    #Calculates where the last codon should start. 
    last_codon_start=len(DNAseq)-2
    codon_list=[]
    #loop to make codons if 1st frame
    for start in range(0, last_codon_start, 3):
        codon=DNAseq[start:start+3]+" "
        codon_list.append(codon)
        #print(codon_list)
    codon_string=''
    codon_string=codon_string.join(codon_list)
    #print(codon_string)
    return codon_string

#function for getting the foward Frames(1,2,3) it works on
# info dictionary createdby Karina's code  
# It makes a new dictionary for the foward frames
# The key = >Accession#/name_of_seq | Frame#
# The value= the seq for that frame split into codons. 
#Author Sandra Shannon
def findingframesfoward(seq): #Author Sandra Shannon
    nextstartbase=0
    frameconter=1
    frames={}
    for key, value in seq.items():
        for start in range(0,3):
            seq=value
            seqofframe=seq[nextstartbase:len(seq)]
            framekey=">"+key+"| Frame"+str(frameconter)
            framevalue=splitintocodon(seqofframe)
            frames[framekey]=framevalue
            #print(frames)
            nextstartbase+=1
            frameconter+=1
        frameconter=1
    print("This is the foward frames:", frames) #comment this out in the final code 
    return frames



#function for getting the reverse Frames(4,5,6) it works on
# on the reverse dictionary created by the makereverse(seq) function 
# It makes a new dictionary for the reverse frames
# The key = >Accession#/name_of_seq | Frame#
# The value= the seq for that frame split into codons. 
#Author Sandra Shannon
def findingframesreverse(seq): #Author Sandra Shannon
    nextstartbase=0
    frameconter=4
    frames={}
    for key, value in seq.items():
        for start in range(0,3):
            seq=value
            seqofframe=seq[nextstartbase:len(seq)]
            framekey=">"+key+"| Frame"+str(frameconter)
            framevalue=splitintocodon(seqofframe)
            frames[framekey]=framevalue
            #print(frames)
            nextstartbase+=1
            frameconter+=1
        frameconter=4
    print("This is the reverse frames:", frames) #comment this out in the final code 
    return frames

#function for open reading frames.
# This function does not work correctly right now. 
#Author Sandra Shannon
def findORF(seqtosearch, orf_length):
    for key, value in seqtosearch.items():
        min=orf_length
        pattern="ATG[AUTGC\s]{" +str(min)+ """,}(TAA|TAG|TGA)"""
        ORF=re.finditer(pattern, value)
        for match in ORF:
            run_start=match.start()
            seq=match.group()
            run_len=len(seq)
            print(key+" POS="+str(run_start)+" LEN="+str(run_len)+"\n"+seq)

# This is the main function will all the functions are called 
# It creats the program. 

def main():
    Seqdic=getfile_info()
    orf_length=get_orflength()
    Fowardframes=findingframesfoward(Seqdic)
    ReverseSeqdic=makereverse(Seqdic)
    Reverseframes=findingframesreverse(ReverseSeqdic)
    #Sandra thinks if we leave the above code the same in the main function things will work nicely 
        #and the others can come in and call their functions. 

    #Just a suggestion-from sandra 
    #You can use the varibles Fowardframes and Reverseframes in the findingORF function
    #like this
    #findORF(Fowardframes, orf_length)

main()

#Sandra's other things to note. from Both the findingframes functions added in the Accession number
    #from the info dictionary this sloves the issues of linking the findingframes Key:vaule back 
    #info key:value. I also made the key to be in the formate that is need for the final output. 
#Sandra's suggestion for the ORF, If you look at my current ORF function there is a print statment
# print(key+" POS="+str(run_start)+" LEN="+str(run_len)+"\n"+seq) It think we could use a version like this
# key+" POS="+str(run_start)+" LEN="+str(run_len) to make the key name for a ORF dictionary and the value would 
#be the seq so it would be something like 
#ORFdic{key+" POS="+str(run_start)+" LEN="+str(run_len):  seq}
#then Seth could use a loop to loop through the dictionary and have it print to a file. 
