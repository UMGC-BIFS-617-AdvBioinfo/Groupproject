#Start group project here. 

#Karina
import os
import re
def main():
    
   def main():
    
    startup_message()#Display the start-up message
    my_seq=input("Enter your file name\n")#ask name of file
    orf_length=eval(input("enter the minimum orf's length ")) 
    #ask for length orf
    info={}#creates dictionary
    with open(my_seq)as file:#open file
        for line in file:
            line=line.upper().rstrip('\n').replace("-","")#convert to upper,get rid of newlines and gaps
            if line.startswith('>'):
                header=line[1:]
                info[header]=''#Here we have the dictionary info with the key header that have all the lines that start with >, there is no value yet
                continue
            else:
                info[header]=info[header]+line#here we add the value(the lines that do not have >
    #print(info)
#Using the values from the dictionary we call the functions(read_file1, read_file2, read_file3) in order to find the reading frames. The argument(x)is
    #each value of the dictionary(each dna sequence)
    
    count=0
    for x in info.values():
        count+=1
        print("sequence",count)#it counts the sequences in the file in order to get a clearer output
        reading1=read_file1(x)
        reading2=read_file2(x)
        reading3=read_file3(x)


        comp_strand=makereverse(x)
        #print("Complementary strand ",comp_strand)    
        re_com_strand=reverse(comp_strand)
        #print("reverse str",re_com_strand)
        reading4=read_file4(re_com_strand)
        #print("reading4",reading4)
        reading5=read_file5(re_com_strand)
        #print("reading5",reading5)
        reading6=read_file6(re_com_strand)
        #print("reading6",reading6)
        start, length, seq=findORF(reading1,orf_length)
        print("|Frame=1, Strand= + ","POS=",start+1,"LEN=",length-1, seq)
        start, length, seq=findORF(reading2,orf_length)
        print("|Frame=2, Srand= +","POS=",start+1,"LEN=",length-1, seq)
        start, length, seq=findORF(reading3,orf_length)
        print("|Frame=3, Strand= +","POS=",start+1,"LEN=",length-1, seq)
        start, length, seq=findORF(reading4,orf_length)
        print("|Frame=1, Strand=- ","POS=",start+1,"LEN=",length-1, seq)
        start, length, seq=findORF(reading5,orf_length)
        print("|Frame=2, Strand= - ","POS=",start+1,"LEN=",length-1, seq)
        start, length, seq=findORF(reading6,orf_length)
        print("|Frame=3,Strand= -","POS=",start+1,"LEN=",length-1, seq)
          
        
#we define the funtions called above    
def startup_message():
    print("""This program will find the orfs in your sequence.Enter the name
    of your sequence and press enter to continue\n\n""")

def read_file1(dna):
    for x in dna:
        reading1=dna[0:]#reading1 starts in the position 0 for each dna sequence(x)=reading frame1
        return reading1
def read_file2(dna): 
    for x in dna:
        reading2=dna[1:]#same position1=reading frame2
        return reading2
def read_file3(dna):
    for x in dna:
        reading3=dna[2:]#same position2=reading frame 3
        return reading3

    

#Sandra

# convert to reverse compliment 
# than use this in a loop to process multiple seqs in a file.
def makereverse(Seq):
    #first change from upper to lowercase
    seqA2t=Seq.replace("A","t")
    seqT2a=seqA2t.replace("T","a")
    seqC2g=seqT2a.replace("C", "g")
    seqG2c=seqC2g.replace("G","c")
    seqdnacomp=seqG2c.upper()
    return seqdnacomp
def reverse(x):
    re_seq=x[::-1]
    return re_seq
def read_file4(dna):
    for x in dna:
        reading4=dna[0:]#reading1 starts in the position 0 for each dna sequence(x)=reading frame1
        return reading4
def read_file5(dna): 
    for x in dna:
        reading5=dna[1:]#same position1=reading frame2
        return reading5
def read_file6(dna):
    for x in dna:
        reading6=dna[2:]#same position2=reading frame 3
        return reading6    


#function for open reading frames.
   
def findORF(dna, orf_length):
    min=orf_length
    pattern="A[TU]G[AUTGC]{" +str(min)+ """,}(TAA|TAG|TGA)"""
    ORF=re.finditer(pattern,dna)
    for match in ORF:
        run_start=match.start()
        run_len=len(dna)
        length=run_len-run_start
        seq=match.group()
        return run_start, length, seq


main()
###Here ends the part that Karina was runing It has parts from Sandra and from me because I put both parts together in order to run the code 
#and see the results.The parts were from before the update that Sandra made yesterday night
#the output until here is:
#seq1
#frame 1 strand+ pos len
#and the sequence
#frame 2 the same
#seq2
#frames 1 until 6 the same. 


#Sandra
#part 3 
#work in progess
#import form my part of code remove in final only need once
import re
# convert to reverse compliment 
# than use this in a loop to process multiple seqs in a file.
# convert to reverse compliment 
# than use this in a loop to process multiple seqs in a file.
#updated makereversefunction to actually reverse and not just complement.
def makereverse(seq): #Author Sandra Shannon
    #first change from upper to lowercase
    seqA2t=seq.replace("A","t")
    seqT2a=seqA2t.replace("T","a")
    seqC2g=seqT2a.replace("C", "g")
    seqG2c=seqC2g.replace("G","c")
    seqdnacomp=seqG2c.upper()
    seqdnareversed=seqdnacomp[::-1]
    return seqdnareversed
    
#new code 16Mar2021
#test sequences 
TestSeq= """CCTCAGCGAGGACAGCAAGGGACTAGCCAGGAGGGAGAACAGAAACTCCAGAACATCTTGGAAATAGCTCCCAGAAAAGCAAGCAGCCAACCAGGCAGGTTCTGTCCCTTTCACTCACTGGCCCAAGGCGCCACATCTCCCTCCAGAAAAGACACCATGAGCACAGAAAGCATGATCCGCGACGTGGAACTGGCAGAAGAGGCACTCCCCCAAAAGATGGGGGGCTTCCAGAACTCCAGGCGGTGCCTATGTCTCAGCCTCTTCTCATTCCTGCTTGTGGCAGGGGCCACCACGCTCTTCTGTCTACTGAACTTCGGGGTGATCGGTCCCCAAAGGGATGAGAAGTTCCCAAATGGCCTCCCTCTCATCAGTTCTATGGCCCAGACCCTCACACTCAGATCATCTTCTCAAAATTCGAGTGACAAGCCTGTAGCCCACGTCGTAGCAAACCACCAAGTGGAGGAGCAGCTGGAGTGGCTGAGCCAGCGCGCCAACGCCCTCCTGGCCAACGGCATGGATCTCAAAGACAACCAACTAGTGGTGCCAGCCGATGGGTTGTACCTTGTCTACTCCCAGGTTCTCTTCAAGGGACAAGGCTGCCCCGACTACGTGCTCCTCACCCACACCGTCAGCCGATTTGCTATCTCATACCAGGAGAAAGTCAACCTCCTCTCTGCCGTCAAGAGCCCCTGCCCCAAGGACACCCCTGAGGGGGCTGAGCTCAAACCCTGGTATGAGCCCATATACCTGGGAGGAGTCTTCCAGCTGGAGAAGGGGGACCAACTCAGCGCTGAGGTCAATCTGCCCAAGTACTTAGACTTTGCGGAGTCCGGGCAGGTCTACTTTGGAGTCATTGCTCTGTGAAGGGAATGGGTGTTCATCCATTCTCTACCCAGCCCCCACTCTGACCCCTTTACTCTGACCCCTTTATTGTCTACTCCTCAGAGCCCCCAGTCTGTATCCTTCTAACTTAGAAAGGGGATTATGGCTCAGGGTCCAACTCTGTGCTCAGAGCTTTCAACAACTACTCAGAAACACAAGATGCTGGGACAGTGACCTGGACTGTGGGCCTCTCATGCACCACCATCAAGGACTCAAATGGGCTTTCCGAATTCACTGGAGCCTCGAATGTCCATTCCTGAGTTCTGCAAAGGGAGAGTGGTCAGGTTGCCTCTGTCTCAGAATGAGGCTGGATAAGATCTCAGGCCTTCCTACCTTCAGACCTTTCCAGATTCTTCCCTGAGGTGCAATGCACAGCCTTCCTCACAGAGCCAGCCCCCCTCTATTTATATTTGCACTTATTATTTATTATTTATTTATTATTTATTTATTTGCTTATGAATGTATTTATTTGGAAGGCCGGGGTGTCCTGGAGGACCCAGTGTGGGAAGCTGTCTTCAGACAGACATGTTTTCTGTGAAAACGGAGCTGAGCTGTCCCCACCTGGCCTCTCTACCTTGTTGCCTCCTCTTTTGCTTATGTTTAAAACAAAATATTTATCTAACCCAATTGTCTTAATAACGCTGATTTGGTGACCAGGCTGTCGCTACATCACTGAACCTCTGCTCCCCACGGGAGCCGTGACTGTAATCGCCCTACGGGTCATTGAGAGAAATAA"""
#function for open reading frames.#Author Sandra Shannon
orf_length=eval(input("enter the minimum orf's length "))#ask for length orf
def findORF(seqtosearch, orf_length):
    min=orf_length
    pattern="A[TU]G[AUTGC]{" +str(min)+ """,}(TAA|TAG|TGA)"""
    for key, value in seqtosearch.items():
        ORF=re.finditer(pattern, value)
        for match in ORF:
            run_start=match.start()
            seq=match.group()
            run_len=len(seq)
            print("|FRAME="+key+" POS="+str(run_start)+" LEN="+str(run_len)+"\n"+seq)


        

#Sandra- todo find 4-6 ORFS, strat postion, len-done startpostion, len and seq
#16Mar2020 sandra new todo match input code to here, creat a new dictorany to store the print("|FRAME... data.)
    
#new code 23Mar2021 SBS
#function for getting the Frames #Author Sandra Shannon
def findingframesfoward(seq): 
    nextstartbase=0
    frameconter=1
    frames={}
    for start in range(0,3):
        seqofframe=seq[nextstartbase:len(seq)]
        key=str(frameconter)
        value=seqofframe
        frames[key]=value
        #print(frames)
        nextstartbase+=1
        frameconter+=1
    return frames

def findingframesreverse(reverseseq): #Author Sandra Shannon
    nextstartbase=0
    frameconter=4
    frames={}
    for start in range(0,3):
        seqofframe=reverseseq[nextstartbase:len(reverseseq)]
        key=str(frameconter)
        value=seqofframe
        frames[key]=value
        #print(frames)
        nextstartbase+=1
        frameconter+=1
    return frames


#Testing stuff
reverseseq=makereverse(TestSeq)       
#print(findingframesfoward(TestSeq))
#print(findingframesreverse(reverseseq))
frowardframes=findingframesfoward(TestSeq)
reverseframes=findingframesreverse(reverseseq)
ORFs=findORF(frowardframes, orf_length)
ORFs=findORF(reverseframes,orf_length)
#to do make the functions makereverse(seq) findingframesfoward(seq) findingframesreverse(reverseseq) work with the input dictonary. This can be done similar to the  findORF function
