#Start group project here. 

#Karina
import os
import re


def main():
    
    startup_message()#Display the start-up message
    my_seq=input("Enter your file name\n")#ask name of file
    orf_length=eval(input("enter the minimum orf's length "))#ask for length orf
    info={}#creates dictionary
    with open(my_seq)as file:#open file
        for line in file:
            line=line.upper().rstrip('\n').replace("-","")#convert to upper,get rid of newlines and gaps
            if line.startswith('>'):
                header=line[1:]
                info[header]=''#Here we have the dictionary info with the key header that have all the lines that start with >, there is no value yet
                continue
            else:
                info[header]=info[header]+line#here we add the value(the lines that do not have >
   
#Using the values from the dictionary we call the functions(read_file1, read_file2, read_file3) in order to find the reading frames. The argument(x)is
    #each value of the dictionary(each dna sequence)
    
    count=0
    for x in info.values():
        count+=1
        print("sequence",count)#it counts the sequences in the file in order to get a clearer output
        reading1=read_file1(x)
        reading2=read_file2(x)
        reading3=read_file3(x)
        
        
       
            
        
        
#we define the funtions called above    
def startup_message():
    print("""This program will find the orfs in your sequence.Enter the name
    of your sequence and press enter to continue\n\n""")

def read_file1(dna):
    for x in dna:
        reading1=dna[0:]#reading1 starts in the position 0 for each dna sequence(x)=reading frame1
        return reading1
def read_file2(dna): 
    for x in dna:
        reading2=dna[1:]#same position1=reading frame2
        return reading2
def read_file3(dna):
    for x in dna:
        reading3=dna[2:]#same position2=reading frame 3
        return reading3

    



main()



#Sandra
#part 3 
#work in progess
# convert to reverse compliment 
# than use this in a loop to process multiple seqs in a file.
# convert to reverse compliment 
# than use this in a loop to process multiple seqs in a file.
#updated makereversefunction to actually reverse and not just complement.
def makereverse(seq):
    #first change from upper to lowercase
    seqA2t=Seq.replace("A","t")
    seqT2a=seqA2t.replace("T","a")
    seqC2g=seqT2a.replace("C", "g")
    seqG2c=seqC2g.replace("G","c")
    seqdnacomp=seqG2c.upper()
    seqdnareversed=seqdnacomp[::-1]
    return seqdnareversed
    
#new code 16Mar2021
#test sequences need to be one long line like this otherwise cause \n in the dictionart
TestSeq= """CCTCAGCGAGGACAGCAAGGGACTAGCCAGGAGGGAGAACAGAAACTCCAGAACATCTTGGAAATAGCTCCCAGAAAAGCAAGCAGCCAACCAGGCAGGTTCTGTCCCTTTCACTCACTGGCCCAAGGCGCCACATCTCCCTCCAGAAAAGACACCATGAGCACAGAAAGCATGATCCGCGACGTGGAACTGGCAGAAGAGGCACTCCCCCAAAAGATGGGGGGCTTCCAGAACTCCAGGCGGTGCCTATGTCTCAGCCTCTTCTCATTCCTGCTTGTGGCAGGGGCCACCACGCTCTTCTGTCTACTGAACTTCGGGGTGATCGGTCCCCAAAGGGATGAGAAGTTCCCAAATGGCCTCCCTCTCATCAGTTCTATGGCCCAGACCCTCACACTCAGATCATCTTCTCAAAATTCGAGTGACAAGCCTGTAGCCCACGTCGTAGCAAACCACCAAGTGGAGGAGCAGCTGGAGTGGCTGAGCCAGCGCGCCAACGCCCTCCTGGCCAACGGCATGGATCTCAAAGACAACCAACTAGTGGTGCCAGCCGATGGGTTGTACCTTGTCTACTCCCAGGTTCTCTTCAAGGGACAAGGCTGCCCCGACTACGTGCTCCTCACCCACACCGTCAGCCGATTTGCTATCTCATACCAGGAGAAAGTCAACCTCCTCTCTGCCGTCAAGAGCCCCTGCCCCAAGGACACCCCTGAGGGGGCTGAGCTCAAACCCTGGTATGAGCCCATATACCTGGGAGGAGTCTTCCAGCTGGAGAAGGGGGACCAACTCAGCGCTGAGGTCAATCTGCCCAAGTACTTAGACTTTGCGGAGTCCGGGCAGGTCTACTTTGGAGTCATTGCTCTGTGAAGGGAATGGGTGTTCATCCATTCTCTACCCAGCCCCCACTCTGACCCCTTTACTCTGACCCCTTTATTGTCTACTCCTCAGAGCCCCCAGTCTGTATCCTTCTAACTTAGAAAGGGGATTATGGCTCAGGGTCCAACTCTGTGCTCAGAGCTTTCAACAACTACTCAGAAACACAAGATGCTGGGACAGTGACCTGGACTGTGGGCCTCTCATGCACCACCATCAAGGACTCAAATGGGCTTTCCGAATTCACTGGAGCCTCGAATGTCCATTCCTGAGTTCTGCAAAGGGAGAGTGGTCAGGTTGCCTCTGTCTCAGAATGAGGCTGGATAAGATCTCAGGCCTTCCTACCTTCAGACCTTTCCAGATTCTTCCCTGAGGTGCAATGCACAGCCTTCCTCACAGAGCCAGCCCCCCTCTATTTATATTTGCACTTATTATTTATTATTTATTTATTATTTATTTATTTGCTTATGAATGTATTTATTTGGAAGGCCGGGGTGTCCTGGAGGACCCAGTGTGGGAAGCTGTCTTCAGACAGACATGTTTTCTGTGAAAACGGAGCTGAGCTGTCCCCACCTGGCCTCTCTACCTTGTTGCCTCCTCTTTTGCTTATGTTTAAAACAAAATATTTATCTAACCCAATTGTCTTAATAACGCTGATTTGGTGACCAGGCTGTCGCTACATCACTGAACCTCTGCTCCCCACGGGAGCCGTGACTGTAATCGCCCTACGGGTCATTGAGAGAAATAA"""

#function for open reading frames.
def findORF(seqtosearch, orf_length):
    min=orf_length
    pattern="A[TU]G[AUTGC]{" +str(min)+ """,}(TAA|TAG|TGA)"""
    ORF=re.finditer(pattern, seqtosearch)
    for match in ORF:
        run_start=match.start()
        seq=match.group()
        run_len=len(seq)
        print("|FRAME=1 "+"POS="+str(run_start)+" LEN="+str(run_len)+"\n"+seq)# need to change frame to match Key name from
        #dictornaris made in findingframesfoward and  findingframesreverse. 
        
ORFs=findORF(Seq,orf_length)
#Sandra- todo find 4-6 ORFS, strat postion, len-done startpostion, len and seq
#16Mar2020 sandra new todo match input code to here, creat a new dictorany to store the print("|FRAME... data.)
    
#new code 23Mar2021 SBS
#function for getting the Frames 
def findingframesfoward(seq): 
    nextstartbase=0
    frameconter=1
    frames={}
    for start in range(0,3):
        seqofframe=seq[nextstartbase:len(seq)]
        key="Frame"+str(frameconter)
        value=seqofframe
        frames[key]=value
        #print(frames)
        nextstartbase+=1
        frameconter+=1
    return frames

def findingframesreverse(reverseseq): 
    nextstartbase=0
    frameconter=4
    frames={}
    for start in range(0,3):
        seqofframe=reverseseq[nextstartbase:len(reverseseq)]
        key="Frame"+str(frameconter)
        value=seqofframe
        frames[key]=value
        #print(frames)
        nextstartbase+=1
        frameconter+=1
    return frames


#Testing stuff
#reverseseq=makereverse(TestSeq)       
#print(findingframesfoward(TestSeq)
#print(findingframesreverse(reverseseq))

#make this third branch ---
